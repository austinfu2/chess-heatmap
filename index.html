<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ChessMap — Heatmap Analyzer</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0d0d0f;
    --surface: #141418;
    --surface2: #1c1c22;
    --border: #2a2a35;
    --text: #e8e4dc;
    --text-muted: #888498;
    --accent: #c8a96e;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'JetBrains Mono', monospace;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.025'/%3E%3C/svg%3E");
    pointer-events: none;
    z-index: 9999;
  }

  header {
    padding: 14px 28px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 16px;
    flex-shrink: 0;
  }
  header h1 { font-family: 'Playfair Display', serif; font-size: 1.2rem; color: var(--accent); }
  header .tagline { font-size: 0.58rem; color: var(--text-muted); letter-spacing: 0.18em; text-transform: uppercase; }

  .layout {
    display: grid;
    grid-template-columns: 230px 1fr 230px;
    flex: 1;
    min-height: 0;
    overflow: hidden;
  }

  .panel {
    border-right: 1px solid var(--border);
    padding: 18px;
    display: flex;
    flex-direction: column;
    gap: 16px;
    overflow-y: auto;
  }
  .panel.right { border-right: none; border-left: 1px solid var(--border); }
  .panel::-webkit-scrollbar { width: 3px; }
  .panel::-webkit-scrollbar-thumb { background: var(--border); }

  .sec { font-size: 0.52rem; letter-spacing: 0.22em; text-transform: uppercase; color: var(--text-muted); margin-bottom: 5px; }

  .drop-zone {
    border: 1px dashed var(--border); border-radius: 3px; padding: 12px;
    text-align: center; font-size: 0.62rem; color: var(--text-muted);
    line-height: 1.6; cursor: pointer; transition: all 0.2s;
  }
  .drop-zone:hover, .drop-zone.over { border-color: var(--accent); color: var(--accent); }

  textarea {
    width: 100%; height: 100px; background: var(--surface2);
    border: 1px solid var(--border); border-radius: 3px;
    color: var(--text); font-family: 'JetBrains Mono', monospace;
    font-size: 0.58rem; padding: 8px; resize: none; outline: none;
  }
  textarea:focus { border-color: var(--accent); }

  .btn-row { display: flex; gap: 5px; margin-top: 6px; }
  .btn {
    flex: 1; background: transparent; border: 1px solid var(--border);
    color: var(--text-muted); font-family: 'JetBrains Mono', monospace;
    font-size: 0.58rem; letter-spacing: 0.06em; padding: 6px;
    cursor: pointer; border-radius: 3px; transition: all 0.15s; text-transform: uppercase;
  }
  .btn:hover { border-color: var(--accent); color: var(--accent); }
  .btn.primary { border-color: var(--accent); color: var(--accent); }
  .btn.primary:hover { background: var(--accent); color: var(--bg); }

  .toggle-row { display: flex; border: 1px solid var(--border); border-radius: 3px; overflow: hidden; }
  .tog {
    flex: 1; background: transparent; border: none;
    border-right: 1px solid var(--border);
    color: var(--text-muted); font-family: 'JetBrains Mono', monospace;
    font-size: 0.52rem; letter-spacing: 0.04em; padding: 7px 3px;
    cursor: pointer; transition: all 0.15s; text-transform: uppercase;
  }
  .tog:last-child { border-right: none; }
  .tog.active { background: var(--surface2); color: var(--text); }

  .slider-row { display: flex; align-items: center; gap: 7px; font-size: 0.56rem; color: var(--text-muted); }
  input[type=range] { flex: 1; accent-color: var(--accent); }

  .move-list { flex: 1; overflow-y: auto; min-height: 0; }
  .move-list::-webkit-scrollbar { width: 3px; }
  .move-list::-webkit-scrollbar-thumb { background: var(--border); }
  .move-pair { display: grid; grid-template-columns: 22px 1fr 1fr; gap: 1px; padding: 1px 2px; border-radius: 2px; }
  .move-pair:hover { background: var(--surface2); }
  .move-num { font-size: 0.58rem; color: var(--text-muted); line-height: 1.8; }
  .move-san { font-size: 0.58rem; padding: 2px 4px; border-radius: 2px; cursor: pointer; line-height: 1.6; transition: color 0.1s; }
  .move-san:hover { color: var(--accent); }
  .move-san.active { background: var(--accent); color: var(--bg); font-weight: 500; }

  /* Center */
  .center {
    display: flex; flex-direction: column; align-items: center;
    justify-content: center; gap: 12px; padding: 16px 12px; overflow: hidden;
  }

  .boards-row { display: flex; gap: 16px; align-items: flex-start; }

  .board-wrap { display: flex; flex-direction: column; align-items: center; gap: 5px; }
  .board-title { font-size: 0.55rem; letter-spacing: 0.15em; text-transform: uppercase; color: var(--text-muted); }

  canvas { display: block; border-radius: 2px; box-shadow: 0 8px 40px rgba(0,0,0,0.7), 0 0 0 1px var(--border); }

  .nav-row { display: flex; gap: 5px; align-items: center; }
  .nav-btn {
    background: var(--surface); border: 1px solid var(--border); color: var(--text);
    width: 32px; height: 32px; border-radius: 3px; cursor: pointer; font-size: 0.8rem;
    display: flex; align-items: center; justify-content: center; transition: all 0.15s;
  }
  .nav-btn:hover { border-color: var(--accent); color: var(--accent); }
  .nav-btn:disabled { opacity: 0.22; cursor: default; pointer-events: none; }
  .move-counter { font-size: 0.6rem; color: var(--text-muted); min-width: 88px; text-align: center; }
  .hint { font-size: 0.53rem; color: #3e3c4a; text-align: center; }

  /* Right panel */
  .color-key { display: flex; flex-direction: column; gap: 8px; }
  .key-row { display: flex; gap: 9px; align-items: flex-start; }
  .key-swatch { width: 36px; height: 20px; border-radius: 3px; flex-shrink: 0; margin-top: 1px; }
  .key-label { display: flex; flex-direction: column; gap: 1px; }
  .key-title { font-size: 0.62rem; font-weight: 500; }
  .key-sub { font-size: 0.53rem; color: var(--text-muted); line-height: 1.35; }

  .mode-desc {
    font-size: 0.58rem; color: var(--text-muted); line-height: 1.55;
    background: var(--surface2); border: 1px solid var(--border);
    border-radius: 3px; padding: 9px;
  }
  .mode-desc strong { color: var(--text); display: block; margin-bottom: 4px; }

  .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
  .stat { background: var(--surface2); border: 1px solid var(--border); border-radius: 3px; padding: 8px; }
  .stat-label { font-size: 0.5rem; color: var(--text-muted); letter-spacing: 0.1em; text-transform: uppercase; margin-bottom: 2px; }
  .stat-val { font-size: 0.9rem; color: var(--text); }
  .stat-val.w { color: #e07040; }
  .stat-val.b { color: #4488ee; }

  .sq-row { display: flex; align-items: center; gap: 5px; padding: 3px 5px; background: var(--surface2); border-radius: 2px; font-size: 0.58rem; margin-bottom: 3px; }
  .sq-name { color: var(--accent); width: 18px; flex-shrink: 0; }
  .sq-bar { flex: 1; height: 3px; background: var(--border); border-radius: 2px; overflow: hidden; }
  .sq-fill { height: 100%; border-radius: 2px; transition: width 0.3s; }
  .sq-count { color: var(--text-muted); font-size: 0.52rem; width: 14px; text-align: right; }

  .fen {
    background: var(--surface2); border: 1px solid var(--border); border-radius: 3px;
    padding: 7px; font-size: 0.5rem; color: var(--text-muted);
    word-break: break-all; line-height: 1.5; cursor: pointer;
  }
  .fen:hover { border-color: var(--accent); }

  .toast {
    position: fixed; bottom: 20px; left: 50%;
    transform: translateX(-50%) translateY(10px);
    background: var(--surface2); border: 1px solid var(--accent);
    color: var(--accent); padding: 6px 16px; border-radius: 3px;
    font-size: 0.6rem; letter-spacing: 0.1em;
    opacity: 0; transition: all 0.25s; z-index: 9998; pointer-events: none;
  }
  .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
</style>
</head>
<body>

<header>
  <h1>♟ ChessMap</h1>
  <span class="tagline">Positional Heatmap Analyzer</span>
</header>

<div class="layout">

  <!-- LEFT -->
  <div class="panel">
    <div>
      <div class="sec">Load PGN</div>
      <div class="drop-zone" id="drop-zone" onclick="document.getElementById('file-in').click()">
        Drop .pgn file here<br>or click to browse
      </div>
      <input type="file" id="file-in" accept=".pgn" style="display:none">
    </div>
    <div>
      <div class="sec">Paste PGN</div>
      <textarea id="pgn-input" placeholder="1. e4 e5 2. Nf3 Nc6...&#10;&#10;Paste any PGN here"></textarea>
      <div class="btn-row">
        <button class="btn primary" onclick="loadPGN()">Load</button>
        <button class="btn" onclick="resetBoard()">Reset</button>
      </div>
    </div>
    <div>
      <div class="sec">Heatmap Mode</div>
      <div class="toggle-row">
        <button class="tog active" data-mode="control" onclick="setMode('control')">Control</button>
        <button class="tog" data-mode="history" onclick="setMode('history')">History</button>
        <button class="tog" data-mode="white" onclick="setMode('white')">White</button>
        <button class="tog" data-mode="black" onclick="setMode('black')">Black</button>
      </div>
    </div>
    <div>
      <div class="sec">Intensity</div>
      <div class="slider-row">
        <span>Low</span>
        <input type="range" id="intensity" min="15" max="100" value="72" oninput="renderHeatmap()">
        <span>High</span>
      </div>
    </div>
    <div style="flex:1;display:flex;flex-direction:column;min-height:0">
      <div class="sec">Moves</div>
      <div class="move-list" id="move-list"></div>
    </div>
  </div>

  <!-- CENTER -->
  <div class="center">
    <div class="boards-row">
      <div class="board-wrap">
        <div class="board-title">Position</div>
        <canvas id="board-canvas"></canvas>
      </div>
      <div class="board-wrap">
        <div class="board-title" id="heat-title">Attack Control</div>
        <canvas id="heat-canvas"></canvas>
      </div>
    </div>
    <div class="nav-row">
      <button class="nav-btn" id="btn-start" onclick="goToMove(0)">⏮</button>
      <button class="nav-btn" id="btn-prev" onclick="prevMove()">◀</button>
      <div class="move-counter" id="move-counter">—</div>
      <button class="nav-btn" id="btn-next" onclick="nextMove()">▶</button>
      <button class="nav-btn" id="btn-end" onclick="goToMove(moves.length)">⏭</button>
    </div>
    <div class="hint">Click pieces to move · Arrow keys ← → to navigate moves</div>
  </div>

  <!-- RIGHT -->
  <div class="panel right">
    <div>
      <div class="sec">Color Key</div>
      <div class="color-key">
        <div class="key-row">
          <div class="key-swatch" style="background:linear-gradient(to right,#3a1800,#ff5500)"></div>
          <div class="key-label"><span class="key-title" style="color:#ff6622">White dominates</span><span class="key-sub">Brighter = more pieces attacking</span></div>
        </div>
        <div class="key-row">
          <div class="key-swatch" style="background:linear-gradient(to right,#111,#ffe000)"></div>
          <div class="key-label"><span class="key-title" style="color:#ffe000">Contested</span><span class="key-sub">Both sides attack — yellow = equal, shifts orange/blue with imbalance</span></div>
        </div>
        <div class="key-row">
          <div class="key-swatch" style="background:linear-gradient(to right,#001838,#2255ff)"></div>
          <div class="key-label"><span class="key-title" style="color:#4477ff">Black dominates</span><span class="key-sub">Brighter = more pieces attacking</span></div>
        </div>
        <div class="key-row">
          <div class="key-swatch" style="background:#0d0d12;border:1px solid #2a2a35"></div>
          <div class="key-label"><span class="key-title" style="color:#444">No coverage</span><span class="key-sub">No pieces reach this square</span></div>
        </div>
      </div>
    </div>
    <div>
      <div class="sec">Mode Guide</div>
      <div class="mode-desc" id="mode-desc"></div>
    </div>
    <div>
      <div class="sec">Position Stats</div>
      <div class="stats-grid">
        <div class="stat"><div class="stat-label">White attacks</div><div class="stat-val w" id="stat-w">—</div></div>
        <div class="stat"><div class="stat-label">Black attacks</div><div class="stat-val b" id="stat-b">—</div></div>
        <div class="stat"><div class="stat-label">Contested sq.</div><div class="stat-val" id="stat-c">—</div></div>
        <div class="stat"><div class="stat-label">Territory edge</div><div class="stat-val" id="stat-d">—</div></div>
      </div>
    </div>
    <div>
      <div class="sec">Hottest Squares</div>
      <div id="top-squares"></div>
    </div>
    <div>
      <div class="sec">FEN <span style="color:#3e3c4a">(click to copy)</span></div>
      <div class="fen" id="fen" onclick="copyFEN()"></div>
    </div>
  </div>

</div>
<div class="toast" id="toast"></div>

<script>
// ── State ──────────────────────────────────────────────────────────────
let SQ = 52;
const boardCanvas = document.getElementById('board-canvas');
const heatCanvas  = document.getElementById('heat-canvas');
const bctx = boardCanvas.getContext('2d');
const hctx = heatCanvas.getContext('2d');

let game = new Chess();
let moves = [];
let moveIndex = 0;
let heatMode = 'control';
let selected = null;
let historyHeat = null;

const MODE_INFO = {
  control: { title: 'Attack Control', desc: '<strong>Attack Control</strong>Orange/red = White dominates. Blue/cyan = Black dominates. Yellow/white = both sides contesting equally. Brightness = total number of pieces covering the square.' },
  history: { title: 'Game History',   desc: '<strong>Game History</strong>Accumulates all attack coverage across every position played so far. Same color logic: orange = White territory, blue = Black territory, bright = heavily fought over.' },
  white:   { title: 'White Coverage', desc: '<strong>White Coverage</strong>Only White\'s attack reach. Dark = no coverage. Dim orange = 1 piece. Bright red/white = many pieces pointing here.' },
  black:   { title: 'Black Coverage', desc: '<strong>Black Coverage</strong>Only Black\'s attack reach. Dark = no coverage. Dim blue = 1 piece. Bright cyan/white = many pieces pointing here.' },
};

// ── Size ───────────────────────────────────────────────────────────────
function calcSize() {
  const center = document.querySelector('.center');
  const w = (center.clientWidth - 32 - 16) / 2;
  const h = center.clientHeight - 72;
  SQ = Math.max(38, Math.min(58, Math.floor(Math.min(w, h) / 8)));
  const bs = SQ * 8;
  boardCanvas.width = boardCanvas.height = bs;
  heatCanvas.width  = heatCanvas.height  = bs;
}
window.addEventListener('resize', () => { calcSize(); render(); });

// ── Pieces ─────────────────────────────────────────────────────────────
const SYMS = { wK:'♔',wQ:'♕',wR:'♖',wB:'♗',wN:'♘',wP:'♙', bK:'♚',bQ:'♛',bR:'♜',bB:'♝',bN:'♞',bP:'♟' };

function drawPiece(ctx, piece, x, y) {
  const sym = SYMS[piece.color + piece.type.toUpperCase()];
  if (!sym) return;
  ctx.save();
  ctx.font = `bold ${SQ * 0.7}px serif`;
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  const cx = x + SQ/2, cy = y + SQ/2;
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.fillText(sym, cx+1.2, cy+1.5);
  ctx.fillStyle = piece.color === 'w' ? '#f2ede4' : '#181410';
  ctx.fillText(sym, cx, cy);
  ctx.strokeStyle = piece.color === 'w' ? 'rgba(0,0,0,0.45)' : 'rgba(255,255,255,0.12)';
  ctx.lineWidth = 0.7;
  ctx.strokeText(sym, cx, cy);
  ctx.restore();
}

// ── Attack heat ────────────────────────────────────────────────────────
function computeAttackHeat(chess) {
  const heat = { w: new Array(64).fill(0), b: new Array(64).fill(0) };
  const board = chess.board();
  for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
    const piece = board[r][c];
    if (!piece) continue;
    const sq = String.fromCharCode(97+c) + (8-r);
    getAttacks(sq, piece, board).forEach(t => {
      const idx = (8 - parseInt(t[1])) * 8 + (t.charCodeAt(0)-97);
      if (idx>=0 && idx<64) heat[piece.color][idx]++;
    });
  }
  return heat;
}

function getAttacks(sq, piece, board) {
  const type=piece.type, color=piece.color;
  const file=sq.charCodeAt(0)-97, rank=parseInt(sq[1])-1;
  const out=[];
  const inB=(f,r)=>f>=0&&f<8&&r>=0&&r<8;
  const toS=(f,r)=>String.fromCharCode(97+f)+(r+1);
  const get=(f,r)=>board[7-r][f];
  const slide=dirs=>dirs.forEach(([df,dr])=>{let f=file+df,r=rank+dr;while(inB(f,r)){out.push(toS(f,r));if(get(f,r))break;f+=df;r+=dr;}});
  const jump=ms=>ms.forEach(([df,dr])=>{const f=file+df,r=rank+dr;if(inB(f,r))out.push(toS(f,r));});
  if(type==='r')slide([[1,0],[-1,0],[0,1],[0,-1]]);
  if(type==='b')slide([[1,1],[1,-1],[-1,1],[-1,-1]]);
  if(type==='q')slide([[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]);
  if(type==='n')jump([[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]);
  if(type==='k')jump([[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]);
  if(type==='p'){const d=color==='w'?1:-1;[-1,1].forEach(df=>{if(inB(file+df,rank+d))out.push(toS(file+df,rank+d));});}
  return out;
}

function normalize(arr) { const m=Math.max(...arr,1); return arr.map(v=>v/m); }

// ── Thermal color ──────────────────────────────────────────────────────
// Maps t∈[0,1] → RGB along classic thermal: black→navy→blue→cyan→green→yellow→orange→red→white
function thermal(t) {
  if (t<=0) return [8,8,16];
  const stops=[
    [0.00,  8,  8, 16],
    [0.08, 18, 18,100],
    [0.18, 25, 70,190],
    [0.30,  0,150,210],
    [0.42,  0,200,120],
    [0.54,100,210,  0],
    [0.64,220,185,  0],
    [0.74,240, 90,  0],
    [0.84,230, 15,  0],
    [0.93,255, 50, 50],
    [1.00,255,240,200],
  ];
  for (let i=1;i<stops.length;i++) {
    if (t<=stops[i][0]) {
      const p=stops[i-1],n=stops[i];
      const f=(t-p[0])/(n[0]-p[0]);
      return [Math.round(p[1]+(n[1]-p[1])*f), Math.round(p[2]+(n[2]-p[2])*f), Math.round(p[3]+(n[3]-p[3])*f)];
    }
  }
  return [255,240,200];
}

// ── Render board ───────────────────────────────────────────────────────
function renderBoard() {
  const bs = SQ*8;
  bctx.clearRect(0,0,bs,bs);
  const board = game.board();

  for (let r=0;r<8;r++) for (let c=0;c<8;c++) {
    const x=c*SQ,y=r*SQ;
    bctx.fillStyle = (r+c)%2===0 ? '#d4bc96' : '#8a6240';
    bctx.fillRect(x,y,SQ,SQ);
    if (selected) {
      const sf=selected.charCodeAt(0)-97, sr=8-parseInt(selected[1]);
      if (sf===c&&sr===r) { bctx.fillStyle='rgba(200,169,110,0.55)'; bctx.fillRect(x,y,SQ,SQ); }
    }
  }

  // Legal move dots
  if (selected) {
    game.moves({square:selected,verbose:true}).forEach(m=>{
      const tf=m.to.charCodeAt(0)-97, tr=8-parseInt(m.to[1]);
      bctx.beginPath();
      bctx.arc(tf*SQ+SQ/2, tr*SQ+SQ/2, SQ*0.13, 0, Math.PI*2);
      bctx.fillStyle='rgba(200,169,110,0.65)'; bctx.fill();
    });
  }

  // Labels
  bctx.font=`${SQ*0.16}px JetBrains Mono,monospace`;
  for (let i=0;i<8;i++) {
    bctx.fillStyle=i%2===0?'#8a6240':'#d4bc96';
    bctx.textAlign='left';bctx.textBaseline='top';
    bctx.fillText(8-i,2,i*SQ+2);
    bctx.fillStyle=i%2===0?'#d4bc96':'#8a6240';
    bctx.textAlign='right';bctx.textBaseline='bottom';
    bctx.fillText(String.fromCharCode(97+i),(i+1)*SQ-2,bs-2);
  }
  for (let r=0;r<8;r++) for (let c=0;c<8;c++) if(board[r][c]) drawPiece(bctx,board[r][c],c*SQ,r*SQ);
}

// ── Render heatmap ─────────────────────────────────────────────────────
function renderHeatmap() {
  const bs = SQ*8;
  hctx.clearRect(0,0,bs,bs);
  const intensity = parseInt(document.getElementById('intensity').value)/100;

  let rawW, rawB;
  if (heatMode==='history' && historyHeat) { rawW=historyHeat.w; rawB=historyHeat.b; }
  else { const h=computeAttackHeat(game); rawW=h.w; rawB=h.b; }

  const nW=normalize(rawW), nB=normalize(rawB);

  for (let r=0;r<8;r++) for (let c=0;c<8;c++) {
    const x=c*SQ, y=r*SQ;
    const idx=r*8+c;
    const hw=nW[idx], hb=nB[idx];

    // Dark checkerboard base — much subtler than chess board
    hctx.fillStyle=(r+c)%2===0?'#18161e':'#100e14';
    hctx.fillRect(x,y,SQ,SQ);

    let rgb=null;

    if (heatMode==='white') {
      if (hw>0.01) {
        // White only: thermal intensity, orange-red tint
        const t = hw*intensity;
        const [tr,tg,tb] = thermal(t);
        rgb = [Math.min(255, tr+40), Math.round(tg*0.6), Math.round(tb*0.3)];
      }
    } else if (heatMode==='black') {
      if (hb>0.01) {
        // Black only: thermal intensity, blue-cyan tint
        const t = hb*intensity;
        const [tr,tg,tb] = thermal(t);
        rgb = [Math.round(tr*0.25), Math.round(tg*0.7+tb*0.15), Math.min(255, tb+30)];
      }
    } else {
      // Control / History
      // Concept: intensity = total coverage (thermal brightness), tint = who dominates
      // Pure white dominant → orange/red palette
      // Pure black dominant → blue/cyan palette  
      // Contested → yellow/white (hot and neutral)
      const hasW=hw>0.02, hasB=hb>0.02;
      if (!hasW && !hasB) {
        rgb=null;
      } else {
        const balance = hasW && hasB ? hw/(hw+hb) : hasW ? 1.0 : 0.0;
        // balance: 1.0=all white, 0.5=equal, 0.0=all black
        // minority: how much the losing side is contesting (0=no contest, 1=equal)
        const minority = hasW && hasB ? Math.min(hw, hb) / Math.max(hw, hb) : 0.0;

        const domIntensity = Math.min(Math.max(hw, hb) * intensity * 1.1, 1.0);
        const brtTotal     = Math.min((hw + hb) * intensity * 0.55, 1.0);

        // Base dominant color
        let dR, dG, dB;
        if (balance >= 0.5) {
          dR = 255; dG = Math.round(85 * domIntensity); dB = Math.round(5 * domIntensity);
        } else {
          dR = Math.round(5 * domIntensity); dG = Math.round(75 * domIntensity); dB = 255;
        }

        // Yellow anchor for equal contest
        const yR = 255, yG = Math.round(228 * brtTotal), yB = Math.round(12 * brtTotal);

        // minority=0 → pure dominant color
        // minority=1 → pure yellow (equal)
        // In between: smoothly shift dominant color toward yellow
        // Use a linear blend so 1v2 (minority=0.5) is visibly halfway
        const t = Math.pow(minority, 0.8); // slight curve so even small minorities register

        rgb = [
          Math.min(255, Math.round(dR * (1-t) + yR * t)),
          Math.min(255, Math.round(dG * (1-t) + yG * t)),
          Math.min(255, Math.round(dB * (1-t) + yB * t)),
        ];
      }
    }

    if (rgb) {
      hctx.fillStyle=`rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
      hctx.fillRect(x,y,SQ,SQ);
    }
  }

  // Subtle coord labels
  hctx.font=`${SQ*0.15}px JetBrains Mono,monospace`;
  hctx.fillStyle='rgba(255,255,255,0.18)';
  for (let i=0;i<8;i++) {
    hctx.textAlign='left';hctx.textBaseline='top';
    hctx.fillText(8-i,2,i*SQ+2);
    hctx.textAlign='right';hctx.textBaseline='bottom';
    hctx.fillText(String.fromCharCode(97+i),(i+1)*SQ-2,bs-2);
  }

  updateStats(rawW,rawB);
}

function render() { renderBoard(); renderHeatmap(); }

// ── Stats ──────────────────────────────────────────────────────────────
function updateStats(rawW, rawB) {
  document.getElementById('fen').textContent=game.fen();
  const wT=rawW.reduce((a,b)=>a+b,0), bT=rawB.reduce((a,b)=>a+b,0);
  let contested=0,wDom=0,bDom=0;
  for(let i=0;i<64;i++){
    if(rawW[i]>0&&rawB[i]>0) contested++;
    else if(rawW[i]>0) wDom++;
    else if(rawB[i]>0) bDom++;
  }
  document.getElementById('stat-w').textContent=wT;
  document.getElementById('stat-b').textContent=bT;
  document.getElementById('stat-c').textContent=contested;
  const diff=wDom-bDom;
  const el=document.getElementById('stat-d');
  el.textContent=diff===0?'Even':diff>0?`W +${diff} sq`:`B +${-diff} sq`;
  el.className='stat-val'+(diff>0?' w':diff<0?' b':'');

  const combined=rawW.map((w,i)=>({i,w,b:rawB[i],total:w+rawB[i]})).sort((a,b)=>b.total-a.total);
  const maxT=combined[0]?.total||1;
  const container=document.getElementById('top-squares');
  container.innerHTML='';
  combined.slice(0,8).forEach(sq=>{
    const f=String.fromCharCode(97+(sq.i%8)), rk=8-Math.floor(sq.i/8);
    const pct=(sq.total/maxT*100).toFixed(0);
    const col=sq.w>sq.b?'#e07040':sq.b>sq.w?'#4488ee':'#999';
    container.innerHTML+=`<div class="sq-row"><span class="sq-name">${f}${rk}</span><div class="sq-bar"><div class="sq-fill" style="width:${pct}%;background:${col}"></div></div><span class="sq-count">${sq.total}</span></div>`;
  });
}

// ── Navigation ─────────────────────────────────────────────────────────
function buildToIndex(idx) {
  game=new Chess();
  historyHeat={w:new Array(64).fill(0),b:new Array(64).fill(0)};
  for(let i=0;i<idx&&i<moves.length;i++){
    const h=computeAttackHeat(game);
    for(let j=0;j<64;j++){historyHeat.w[j]+=h.w[j];historyHeat.b[j]+=h.b[j];}
    game.move(moves[i]);
  }
  moveIndex=idx;
}

function goToMove(idx){
  idx=Math.max(0,Math.min(idx,moves.length));
  buildToIndex(idx); updateMoveList(); updateNav(); render();
}
function nextMove(){if(moveIndex<moves.length)goToMove(moveIndex+1);}
function prevMove(){if(moveIndex>0)goToMove(moveIndex-1);}

function updateNav(){
  document.getElementById('btn-prev').disabled=moveIndex===0;
  document.getElementById('btn-start').disabled=moveIndex===0;
  document.getElementById('btn-next').disabled=moveIndex===moves.length;
  document.getElementById('btn-end').disabled=moveIndex===moves.length;
  const el=document.getElementById('move-counter');
  if(!moves.length){el.textContent='—';}
  else if(moveIndex===0){el.textContent='Start';}
  else{const n=Math.ceil(moveIndex/2);el.textContent=`${n}. ${moveIndex%2===1?'White':'Black'}`;}
}

// ── PGN ────────────────────────────────────────────────────────────────
function loadPGN(){
  const pgn=document.getElementById('pgn-input').value.trim();
  if(!pgn)return;
  const tmp=new Chess();
  if(!tmp.load_pgn(pgn,{sloppy:true})){showToast('Invalid PGN');return;}
  moves=tmp.history(); game=new Chess(); moveIndex=0;
  historyHeat={w:new Array(64).fill(0),b:new Array(64).fill(0)};
  updateMoveList(); updateNav(); render();
  showToast(`Loaded — ${moves.length} moves`);
}

function updateMoveList(){
  const el=document.getElementById('move-list');
  el.innerHTML='';
  for(let i=0;i<moves.length;i+=2){
    const n=i/2+1, wi=i+1, bi=i+2;
    el.innerHTML+=`<div class="move-pair"><span class="move-num">${n}.</span><span class="move-san ${moveIndex===wi?'active':''}" onclick="goToMove(${wi})">${moves[i]||''}</span><span class="move-san ${moves[i+1]&&moveIndex===bi?'active':''}" onclick="goToMove(${bi})">${moves[i+1]||''}</span></div>`;
  }
  el.querySelector('.active')?.scrollIntoView({block:'nearest'});
}

// ── Mode ───────────────────────────────────────────────────────────────
function setMode(mode){
  heatMode=mode;
  document.querySelectorAll('.tog').forEach(b=>b.classList.toggle('active',b.dataset.mode===mode));
  document.getElementById('heat-title').textContent=MODE_INFO[mode].title;
  document.getElementById('mode-desc').innerHTML=MODE_INFO[mode].desc;
  renderHeatmap();
}

// ── Interactive board ──────────────────────────────────────────────────
boardCanvas.addEventListener('click',e=>{
  const rect=boardCanvas.getBoundingClientRect();
  const col=Math.floor((e.clientX-rect.left)/rect.width*8);
  const row=Math.floor((e.clientY-rect.top)/rect.height*8);
  const sq=String.fromCharCode(97+col)+(8-row);
  const piece=game.get(sq);
  if(selected){
    const result=game.move({from:selected,to:sq,promotion:'q'});
    if(result){
      if(moveIndex<moves.length)moves=moves.slice(0,moveIndex);
      moves.push(result.san); moveIndex++; selected=null;
      updateMoveList(); updateNav();
    } else if(piece&&piece.color===game.turn()){selected=sq;}
    else{selected=null;}
  } else {
    selected=(piece&&piece.color===game.turn())?sq:null;
  }
  render();
});

// ── Keys ───────────────────────────────────────────────────────────────
document.addEventListener('keydown',e=>{
  if(e.key==='ArrowRight'){nextMove();e.preventDefault();}
  if(e.key==='ArrowLeft'){prevMove();e.preventDefault();}
  if(e.key==='ArrowUp'){goToMove(moves.length);e.preventDefault();}
  if(e.key==='ArrowDown'){goToMove(0);e.preventDefault();}
});

// ── File drop ──────────────────────────────────────────────────────────
const dz=document.getElementById('drop-zone'), fi=document.getElementById('file-in');
dz.addEventListener('dragover',e=>{e.preventDefault();dz.classList.add('over');});
dz.addEventListener('dragleave',()=>dz.classList.remove('over'));
dz.addEventListener('drop',e=>{e.preventDefault();dz.classList.remove('over');if(e.dataTransfer.files[0])readFile(e.dataTransfer.files[0]);});
fi.addEventListener('change',e=>{if(e.target.files[0])readFile(e.target.files[0]);});
function readFile(f){const r=new FileReader();r.onload=e=>{document.getElementById('pgn-input').value=e.target.result;loadPGN();};r.readAsText(f);}

// ── Util ───────────────────────────────────────────────────────────────
function resetBoard(){
  game=new Chess();moves=[];moveIndex=0;selected=null;
  historyHeat={w:new Array(64).fill(0),b:new Array(64).fill(0)};
  document.getElementById('pgn-input').value='';
  updateMoveList();updateNav();render();
}
function copyFEN(){navigator.clipboard.writeText(game.fen()).then(()=>showToast('FEN copied'));}
function showToast(msg){const t=document.getElementById('toast');t.textContent=msg;t.classList.add('show');setTimeout(()=>t.classList.remove('show'),2000);}

// ── Init ───────────────────────────────────────────────────────────────
calcSize();
setMode('control');
updateNav();
render();
</script>
</body>
</html>
